import { RouletteReward, GameSettings } from '../types/game';

export const GAME_SETTINGS: GameSettings = {
  timer: 10,
  canvasWidth: 360,
  canvasHeight: 640,
  brushSize: 48,
  botSpeed: 8,
  powerUpDuration: 4500,
  powerUpSpawnInterval: 3000,
  dailyGameLimit: 50,
  botDifficulty: {
    minScore: 40,
    maxScore: 60,
    adaptiveSpeed: true,
    powerUpSeekChance: 0.6
  }
};

export const ROULETTE_REWARDS: RouletteReward[] = [
  { type: 'onChainToken', amount: 1000, label: '1K $CC', probability: 0.55 },
  { type: 'onChainToken', amount: 5000, label: '5K $CC', probability: 0.20 },
  { type: 'onChainToken', amount: 10000, label: '10K $CC', probability: 0.15 },
  { type: 'onChainToken', amount: 50000, label: '50K $CC', probability: 0.05 },
  { type: 'inGameCurrency', amount: 2, label: '+2 Keys', probability: 0.00 },
  { type: 'noReward', amount: 0, label: 'Try Again', probability: 0.05 },
];

// Contract addresses - update these with your deployed contract addresses
export const CONTRACT_ADDRESSES = {
  CC_TOKEN: import.meta.env.VITE_CC_TOKEN_ADDRESS || '0x1234567890123456789012345678901234567890',
  REWARD_DISTRIBUTOR: import.meta.env.VITE_REWARD_DISTRIBUTOR_ADDRESS || '0x2345678901234567890123456789012345678901',
  SCORE_RECORDER: import.meta.env.VITE_SCORE_RECORDER_ADDRESS || '0x3456789012345678901234567890123456789012',
};

// Validate critical environment variables
if (!import.meta.env.VITE_CC_TOKEN_ADDRESS) {
  console.warn('⚠️  VITE_CC_TOKEN_ADDRESS not set - using placeholder address');
}
if (!import.meta.env.VITE_REWARD_DISTRIBUTOR_ADDRESS) {
  console.warn('⚠️  VITE_REWARD_DISTRIBUTOR_ADDRESS not set - using placeholder address');
}
if (!import.meta.env.VITE_SCORE_RECORDER_ADDRESS) {
  console.warn('⚠️  VITE_SCORE_RECORDER_ADDRESS not set - using placeholder address');
}
// Bot Difficulty Presets - Easy to configure different difficulty levels
export const BOT_DIFFICULTY_PRESETS = {
  EASY: {
    minScore: 20,
    maxScore: 40,
    adaptiveSpeed: true,
    powerUpSeekChance: 0.3
  },
  MEDIUM: {
    minScore: 40,
    maxScore: 60,
    adaptiveSpeed: true,
    powerUpSeekChance: 0.6
  },
  HARD: {
    minScore: 60,
    maxScore: 80,
    adaptiveSpeed: true,
    powerUpSeekChance: 0.8
  },
  EXPERT: {
    minScore: 70,
    maxScore: 90,
    adaptiveSpeed: true,
    powerUpSeekChance: 0.9
  }
};

// Contract ABIs - these would be generated from your compiled contracts
export const CONTRACT_ABIS = {
  REWARD_DISTRIBUTOR: [
    "function distributeReward(address recipient, string memory playerName, uint256 amount) external",
    "function claimRewardWithSignature(address recipient, uint256 amount, uint256 nonce, bytes memory signature) external",
    "function getContractBalance() external view returns (uint256)",
    "function isNonceUsed(address recipient, uint256 amount, uint256 nonce) external view returns (bool)",
    "event RewardDistributed(address indexed recipient, string playerName, uint256 amount)"
  ],
  SCORE_RECORDER: [
    "function recordScore(uint256 score, string memory playerName) external",
    "event ScoreRecorded(address indexed player, string playerName, uint256 score, uint256 timestamp, uint256 gameNumber)"
  ],
  ERC20: [
    "function balanceOf(address owner) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "function approve(address spender, uint256 amount) returns (bool)",
  ],
};










import { createConfig, http } from '@wagmi/core';
import { arbitrum } from '@wagmi/core/chains';
import { farcasterMiniApp } from '@farcaster/miniapp-wagmi-connector';
import { injected } from '@wagmi/connectors';

export const wagmiConfig = createConfig({
  chains: [arbitrum],
  connectors: [
    farcasterMiniApp({
      relay: 'https://relay.farcaster.xyz',
    }),
    injected()
  ],
  transports: {
    [arbitrum.id]: http()
  },
});








import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { ethers } from "npm:ethers@6.15.0";
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Client-Info, Apikey"
};
const SCORE_RECORDER_ABI = [
  "function recordScore(uint256 score, string memory playerName) external",
  "event ScoreRecorded(address indexed player, string playerName, uint256 score, uint256 timestamp, uint256 gameNumber)"
];
Deno.serve(async (req)=>{
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders
    });
  }
  try {
    const { walletAddress, score, contractAddress, playerName } = await req.json();
    if (!walletAddress || score === undefined || !contractAddress || !playerName) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing required fields: walletAddress, score, contractAddress, playerName"
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    if (score < 0 || score > 100) {
      return new Response(JSON.stringify({
        success: false,
        error: "Score must be between 0 and 100"
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    const rpcUrl = Deno.env.get("ARBITRUM_RPC_URL") || "https://arb1.arbitrum.io/rpc";
    const adminPrivateKey = Deno.env.get("ADMIN_PRIVATE_KEY");
    if (!adminPrivateKey) {
      return new Response(JSON.stringify({
        success: false,
        error: "Server configuration error: missing private key"
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    const provider = new ethers.JsonRpcProvider(rpcUrl);
    const wallet = new ethers.Wallet(adminPrivateKey, provider);
    const contract = new ethers.Contract(contractAddress, SCORE_RECORDER_ABI, wallet);
    const tx = await contract.recordScore(score, playerName);
    const receipt = await tx.wait();
    return new Response(JSON.stringify({
      success: true,
      transactionHash: receipt.hash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed.toString(),
      walletAddress,
      playerName,
      score
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  } catch (error) {
    console.error("Error recording score:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Failed to record score on-chain",
      details: error.toString()
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
});








edge function



import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { ethers } from "npm:ethers@6.15.0";
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Client-Info, Apikey"
};
Deno.serve(async (req)=>{
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders
    });
  }
  try {
    const { walletAddress, rewardAmount, playerName } = await req.json();
    if (!walletAddress || !rewardAmount) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing required fields: walletAddress, rewardAmount"
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    if (rewardAmount <= 0) {
      return new Response(JSON.stringify({
        success: false,
        error: "Reward amount must be greater than 0"
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    // Validate wallet address format
    if (!ethers.isAddress(walletAddress)) {
      return new Response(JSON.stringify({
        success: false,
        error: "Invalid wallet address format"
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    const adminPrivateKey = Deno.env.get("ADMIN_PRIVATE_KEY");
    if (!adminPrivateKey) {
      return new Response(JSON.stringify({
        success: false,
        error: "Server configuration error: missing admin private key"
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    // Generate a unique nonce (timestamp + random number)
    const nonce = Date.now() * 1000 + Math.floor(Math.random() * 1000);
    // Create the message hash that will be signed
    const messageHash = ethers.solidityPackedKeccak256([
      "address",
      "uint256",
      "uint256"
    ], [
      walletAddress,
      rewardAmount,
      nonce
    ]);
    // Sign the message hash
    const wallet = new ethers.Wallet(adminPrivateKey);
    const signature = await wallet.signMessage(ethers.getBytes(messageHash));
    return new Response(JSON.stringify({
      success: true,
      walletAddress,
      playerName: playerName || walletAddress.slice(0, 8),
      rewardAmount: rewardAmount.toString(),
      nonce: nonce.toString(),
      signature,
      messageHash
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  } catch (error) {
    console.error("Error generating claim signature:", error);
    return new Response(JSON.stringify({
      success: false,
      error: "Failed to generate claim signature",
      details: error.message || error.toString()
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
});
